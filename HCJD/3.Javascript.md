# 三、JavaScript

---

2018.11.10开始添加ES6的新知识点。

---
## 目录
* 3.1 [JS的介绍][3.1]
* 3.2 [JS的调试][3.2]
* 3.3 [JS语法][3.3]
* 3.4 [JS的基本数据类型][3.4]
* 3.5 [操作符和表达式][3.5]
* 3.6 [语句][3.6]
* 3.7 [数值][3.7]
* 3.8 [字符串][3.8]
* 3.9 [对象][3.9]
* 3.10 [数组][3.10]
* 3.11 [函数][3.11]
* 3.12 [Date日期][3.12]
* 3.13 [正则表达式RegExp][3.13]
* 3.14 [JSON][3.14]
* 3.15 [类型进阶][3.15]
* 3.16 [函数进阶][3.16]
* 3.17 [原型进阶][3.17]
* 3.18 [变量作用域进阶][3.18]
* 3.19 [闭包进阶][3.19]
* 3.20 [面向对象编程进阶][3.20]
---
### 3.1 JS的介绍
#### 3.1.1 JS的基本语法
在web开发的过程中，`html`/`css`/和`JavaScript`分别扮演了不同的角色。

| 语言种类   | 在web开发中的作用                       |
| :-: | :-: |
| HTML       | 在web开发中主要用来完成页面的结构和内容 |
| CSS        | 负责页面的显示样式                      |
| JavaScript | 控制页面的动态交互和行为                |

JavaScript的hello，world：
```html
<!-- hello,wold -->
<!DOCTYPE html>
<html>
<head></head>
<body>
<script>
    document.write("hello,world");
<script>
</body>
</html>
```
在HTML中引入JS：
```html
<!-- 在HTML中引入JavaScript的方法一：内嵌法 -->
<!DOCTYPE html>
<html>
<head><head>
<body>
<script>
    document.write("hello,world");
</script>
</body>
</html>

<!-- 在HTML中引入JavaScript的方法二：外联法 -->
<!DOCTYPE html>
<html>
<head></head>
<body>
    <script src="helloWorld.js"></script>
</body>
</html>
```
#### 3.1.2 JS的特性
JavaScript是解释性语言，而不是编译性语言；在支持JavaScript的浏览器中运行的过程中没有编译过程，而是`逐行解释执行`。
```javascript
var number = 1;
while (number < 1000) {
    document.write('<p>' + number + '</p>');
    number = number +1;
}
/* 上面这段JavaScript程序，其表达的意思只要会英语就能够理解。浏览器执行的时候也是按照我们的书写逻辑顺序进行执行的。 */
```
#### 3.1.3 JS的学习结构
就像我们写文章需要经历一个如`字词-->短语-->句子-->文章`的过程；<br>
学习`javascript`需要经历一个从`变量-->表达式-->语句--写程序`的过程.<br>

在浏览器中的运行的`js`要满足`DOM`的规则要求，也就是`ECMAScript`，就像写合同要按照合同的规范一样。
>ECMAScript + DOM(Document Object Model) = 浏览器中的JS
#### 3.1.4 JS的历史
[1995:Netscape Navigator 2.0 js诞生]-->[1997:ECMAScript 1 DHTML]-->[1998:W3C DOM规范]
-->[2000:ECMAScript 3]-->[2005:Ajax Web2.0]-->[2011:ECMAScript 5.1]-->[2015:ECMAScritpt 6]

### 3.2 JS的调试
JS直接在浏览器中进行测试，或者用专用的测试软件测试；
>在浏览器中调试的方法：`F12`、`审查元素`;
>功能审查：`alert`、`console.log();`、`js调试器`;
#### 3.2.1 js的调试工具
谷歌浏览器的调试器：<br>

![谷歌浏览器调试器](https://github.com/Wanlin-Lu/Front-end-knowledge-summary/blob/master/images/3.2.1.png)
>主要使用`source`和`断点调试`工具；
>调试：（F12、Ctrl+shift+i、右键+审查元素）

### 3.3 JS的语法
JS的语法主要指`变量`、`表达式`、`语句`、`对象`、`函数`的**定义**、**构成**和**使用**的规则；
#### 3.3.1 变量、直接量和标识符
* 直接量
>`var number=1;中的‘1’`,以及`1.2`,`"hello,world"`,`true`,`false`,`null`,`[]`,`{name:'js'}`等，在赋值符号“=”后面的都是直接量。
* 变量
>`var number=1;`中的‘number’，以及其他用`var`定义的用来储存值的都是变量。如：`var age;`,`var age,name,sex;`
* 标识符
    * `直接量`和`变量`的命名以`字母`,`下划线`或者`$`开头，以`字母`,`下划线`,`$`,`数字`组成
    * 不能使用`关键字`和`保留字`;
    * 字母的大小写敏感；
```javascript
var age = 12;//变量age，赋值为12；
function add(num1,num2){
    return num1 + num2;
}
var student = {
    name:"小明"
}//变量student，赋值为对象{name：“小明”}
```
```html
<!-- 关键字 -->
break/case/catch/continue/debugger/default/in/do/else/finally/for/function/if/try
/instanceof/new/return/switch/this/throw/typeof/var/void/while/with/delete
<!-- /关键字 -->

<!-- 保留字 -->
abstract/enum/int/short/boolean/export/interface/static/byte/extends/long/super/Char
/final/native/synchronized/Class/float/package/throws/Const/goto/private/transient
/debugger/implements/protected/volatile/double/import/public
<!-- /保留字 -->
```
```javascript
/* 大小写敏感 */
var age = 10;
var Age = 20;
document.write(age);//10
document.wiite(Age);//20
```
#### 3.3.2 语句
```javascript
/* if-else条件例句 */
var sex = 1;
if(sex == 1){
    document.write('男');
}else{
    document.write('女');
}

/* while条件例句 */
while(number<1000){
    document.write('<p>' + number + '</p>');
    number = number + 1;
}
```
#### 3.3.3 注释
```javascript
/*
* 计算两个数字的和
* @param [Number] num1 第一个数字
* @param [Number] num2 第二个数字
* @return [Number] 两个数字的和
*/
function sum(num1,num2){
    return num1 + num2;//把两个数字加起来
}
```
### 3.4 JS基本的数据类型
js的基本数据类型有6种：`Number`,`String`,`Boolean`,`Object`,`Null`,`Undefined`
#### 3.4.1 Number
* 整数
    * 15（十进制）`var num = 10;//10`
    * 0377（八进制）`var num = 070;//56`
    * 0xff（十六进制）`var num = `
* 浮点数
    * 1.2 `var num = 3.141592653;`
    * 1.4E2（科学计数法） `var num = 3.14e2;`
* 特殊值
    * NaN（Not a Number）
    * Infinity（无限大）`var num = 1/0;//Infinity`

#### 3.4.2 String
放在`双引号`或者`单引号`中的值类型就是`string类型`。<br>
```javascript
var name = "hello";//双引号
var name = 'july';//单引号
```
#### 3.4.3 boolean
Boolean类型只有两个值，`true`和`false`;
```javascript
var sex = true;
if(sex){
    document.write('male');
}else{
    document.write('female');
}
```
#### 3.4.4 Object
Object（对象）是`一组无序的名值对的集合`;
```javascript
/* 把一个对象实体赋值给一个变量`cat` */
var cat = { 
    name:'kitty',//名值对之间是`逗号`隔开的
    age:2,
    mew:function(){
        console.log('miao miao miao');
    }
}
/* 用`new`方法，定义一个新的对象 */
var dog = new Object();
```
#### 3.4.5 Null
Null类型的值只有一个`null`,出现这个值的意思是`对象不存在`;
`var car = null;`
#### 3.4.6 Undefined
Undefined类型只有一个值`undefined`;<br>
出现的场景有二：`已声明未赋值的变量`和`获取对象不存在的属性`
#### 3.4.7 类型识别-typeof
```javascript
var num;
typeof num;//undefined
var num = 1;
typeof num;//number
var num = '1';
typeof num;//string
var num = true;
typeof num;//boolean
var num = null;
typeof num;//object
```
#### 3.4.8 原始类型和引用类型
JS的6中基本数据类型，`Number`,`String`,`Boolean`,`Undefined`,`Null`为`原始类型`；而`Object`是`引用类型`；<br>
`原始类型`的数据赋值后，就形成了对应的名值对；<br>
`引用类型`的数据赋值时，只是把一个值的`地址`赋予了一个变量；
```javascript
/* 原始类型 */
var num1 = 123;
var num2 = num1;
num2 = 456;
console.log(num1);//123

/* 引用类型 */
var obj1 = {a:1,b:2};
var obj2 = obj1;
obj2.a = 3;
console.log(obj1.a);//3
```

### 3.5 操作符和表达式
```text
/* js操作符汇总 */
一元操作符（++ ，--）
算术操作符（+ ，- ，* ，/，%)
关系操作符（> ,< ,>= ,<=）
相等操作符（== ,!= ,=== ,!==）
逻辑操作符（! ,&& ,||）
赋值操作符（=）
条件操作符（?:）
逗号操作符（,）
对象操作符（new ,delete ,[] ,instanceof ,in）
位操作符（~ ,& ,| ,^ ,<< ,>> ,>>>）
```
#### 3.5.1 一元操作符（++ ，--）
```javascript
var age = 29;
++age;//30
age++;//31

var age = 29;
var num = age++;//num = 29,因为`var num = age++`是先使用后`++`的
```
#### 3.5.2 算术操作符（+ ，- ，* ，/ ，%）
```javascript
var num = 5 + 6;//11
```
#### 3.5.3 关系操作符（> ,< ,>= ,<=)
```javascript
var result = 6>4;
aler(result);//true
```
#### 3.5.4 相等操作符（== ,!= ,=== ,!==）
```javascript
var num = 4;
num == 4;//true

var num = "4";
num == 4;//true

0 == false;//true
2 == true;//false
'' == 0;//true

var num = "4";
num === 4;//false
num !== 4;//true
```
#### 3.5.5 逻辑操作符（! ,&& ,||）
```javascript
/* 非：‘!’ */
var flag = true;
alert(!flag);//false
---
alert(!0);//true
alert(![]);//false
alert(!"");true
---

/* 与：‘&&’ (短路的操作，有一个为true，则整个表达式的值为另一个 */
var result = true && false;//false
var result = true && 3;//3
var result = 1 && 3;//3
var result = [] && "";//""

/* 或：‘||’ （短路的操作，如果第一个为true，则值为第一个；否则值为第二个 */
var result = true || 3;//true
var result = 1 || 3;//1
var result = [] || "";//[]
var result = false || 0;//0
var result = "" ||3;//3
var result = null || true;//true
---
var num = 0;
var result = 3 || num++;//3(应该是，待验证！！，经过验证，是正确的！)
```
#### 3.5.6 赋值操作符（=）
```javascript
var num = 5;//5
num = mum + 5;//10
mun +=5;//15
```
#### 条件操作符（？：）
```javascript
/*
布尔表达式 ？ 值一 ： 值二 ；
若‘布尔表达式’的值为true，则上式的值为‘值一’，否则为‘值二’
*/
---
var result;
var sex = true;
if(sex){
    result = 'male';
}else{
    result = 'female';
}
---
/* 上面的语句可以用条件操作符改写如下 */
var sex = true;
var result = sex ? 'male' : 'female';
```
#### 3.5.7 逗号操作符（，）
```javascript
var num1 = 5;
var num2 = 10;
var num3 = 0.5;
/* 上面的三个式子可以用逗号操作符改写如下 */
var num1 = 5,num2 = 10,num3 = 0.5;
```
#### 3.5.8 对象操作符（new/delete/./[]/instanceof/in）
```javascript
var cat = new Object();//用方法new来定义cat为一个对象
---
var cat = {name:'kitty',age:2};
aler(cat.name);//'kitty'
delet cat.name;
alert(cat.name);//undefined
---
var cat = {name:'kitty',age:2};
alert(cat.name);//'kitty'
alert(cat['name']);//'kitty'
---
var cat = {name:'kitty',age:2};
alert(cat instanceof Object);//true
alert(cat instanceof Number);//false
---
var cat = {name:'kitty',age:2};
alert('name' in cat);//true
alert('run' in cat);//false
```
#### 3.5.9 位操作符（~，&，|，^，<<，>>，>>>）
这里的`位操作符`是针对二进制数字的操作，详情待研究！！！；
```javascript
var num = 8;
num & 4;//意思是8的二进制数字`1000`和4的二进制数字`0100`对位比较，相同为1，不同为0，结果为0
---
var num = 2;
num <<1;//意思是2的二进制数字`0010`中的‘1’向左移动1位，结果为`0100`即为4
num <<2;//意思是2的二进制数字`0010`中的‘1’向左移动2位，结果为`1000`即为8
```
#### 3.5.10 操作符优先级
```javascript
var num = 5 + 4 * 3;//17
4 + 0 || 3;//4
!false && [];//[]
4>3?5:7+10;//5
```
### 3.6 语句
js语句分为：`条件语句`,`循环语句`,`with语句`,`异常捕获语句`;
#### 3.6.1 条件语句
```JavaScript
/* if(条件){语句1}else{语句2} */
var isMale = false;
if(isMale){
    document.write('male');
}else{
    document.write('female');
}
//female

/* if(条件1){语句1}else if(条件2){语句2}else{语句3} */
var score = 65;
if(score > 70){
    document.write('A');
}else if(score >=60){
    document.write('B');
}else{
    document.write('C');
}
//B

/* switch(表达式){case值1:result1;break;case值2:result2;break;default:result3} */
var degree = 'B';
switch(degree){
    case'A':
        document.write('Excilent');
        break;
    case'B':
        document.write('good');
        break;
    default:
        document.write('need more effort');
    }
    //good
```
#### 3.6.2 循环语句
```javascript
/* while(表达式){语句} */
var i = 1;
while(i<=10){
    document.write(i);
    i++;
}
//12345678910

/* do{语句}while(表达式) */
var i = 11;
do{
    document.write(i);
    i++;
}
while(i<=10)
//11，经过实验结果应该为12345678910，到不了11

/* for(初始化；循环条件；更新表达式){语句} */
for(var i = 1;i<=10;i++){
    document.write(i);
}
//这个for循环和前面while循环的结果是一样的：12345678910
/* 在for循环中还有两个关键词：`break`和`continue`,用法如下 */
for(var i=1;i<=10;i++){
    if(i == 5){break;}
    document.write(i);
}
//1234
for(var i=1;i<=10;i++){
    if(i ==5){continue;}//这里if语句和document语句的顺序会影响结果的输出，要注意！
    document.write(i);
}
//1234678910

/* for(属性名 in 对象){语句} */
---
var cat = {
    neme:'kitty',
    age:2,
    mew:function(){
        console.log('miao miao miao');
    }
}
---
for(var p in cat){
    document.write(p);
}
//name age mew
```
#### 3.6.3 with语句
```javascript
var kitty = {
    age:3,
    friend:{
        neme:'snoopy',
        age:2
    }
}
---
document.write(kitty.friend.name +'\'s age is' +kitty.friend.age);
//snoopyk's age is2
---

/* with(表达式){语句} */
with(kitty.friend){
    document.write(name +'\'s age is' +age);
}
```
#### 3.6.4 异常捕获语句
```javascript
/* try{语句}catch(exception){语句}finally{语句} */
try{
    document.write(notDefined);
}catch(error){
    alert(error);
}finally{
    alert('finally');
}
//ReferenceError:...
//finally
```
### 3.7 数值
#### 3.7.1 数值方法
```javascript
/* 绝对值：Math.abs(x) */
Math.abs(5);//5
Math.abs(-5);//5

/* 四舍五入：Math.round(x) */
Math.round(1.1);//1
Math.round(1.9);//2
//经实验发现Math.round(负数)时是五舍六入；

/* 向上取整：Math.ceil(x) */
Math.ceil(1.1);//2
Math.ceil(1.9);//2

/* 向下取整：Math.floor(x) */
Math.floor(1.1);//1
Math.floor(1.9);//1

/* 最大值：Math.max([value1[,value2[,...]]]) */
Math.max(1,2,3,4);//4
Math.max(-1,-2,-3);//-1

/* 最小值：Math.min([value1[,value2[,...]]]) */
Math.min(1,2,3,4);//1
Math.min(-1,-2,-3);//-3

/* 随机值：Math.random() */
Math.random();//0<=Math.random()<1;0.962838234971341034034137403847137487348718374

/* 余弦值：Math.cos(弧度) */
/* e次方：Math.exp(x) */
/* 幂数：Math.log(x) */
/* 平方根：Math.sqrt(x) */
/* x的y次方：Math.pow(x,y) */
```
#### 3.7.2 数值类型的转换
```javascript
/* 字符串化为整型：parseInt(string,radix) */
parseInt('1.1');//1
parseInt('1.9');//1
parseInt('1b2.4');//1
parseInt('www');//NaN

/* 字符串化为保留小数点：pareFloat(string) */
parseFloat('100.1');//100.1
parseFloat('12.4b5');//12.4
parseFloat('www');//NaN

/* 字符串数值化：Number（value） */
Number('100.1');//100.1
Number('12.4b5');//NaN
Number('www');//NaN

/* 保留n位小数点 num.toFixed(digits) */
(100.123).toFixed(2);//"100.12"
(100.123).toFixed(0);//"100"
```
### 3.8 字符串
#### 3.8.1 字符串的定义
```javascript
/* 凡是引号当中的内容都是字符串；?? */
"该号码可注册"
"12916316319"
""
"http://www.163.com"
'http://www.163.com'
```
#### 3.8.2 字符串的长度
```javascript
/* str.length */
"micromajo".length   //10
---
var userName = input.value;//"micromajor"
if(userName.length<6){
    alert("userName must be longer than 6");
}
---
```
#### 3.8.3 字符串索引位置
```javascript
/* str.charAt(index) */
"micromajor".charAt(0) //m
---
var userName = input.value;//"-micromajor"
if(userName.charAt(0) == "-"){
    alert("userName can't start with '-'");
}
---
```
#### 3.8.4 字符串检索匹配：indexOf（）
```javascript
/* str.indexOf(searchValue[,fromIndex]) */
"micro-major".indexOf("-")  //5
"micro-major-web".indexOf("-")  //5
"micro-major".indexOf("major")  //6
"micro-major".indexOf("-")  //-1
---
var userName = input.value;//"micromajor"
if(userName.indexOf("-") == -1){
    alert("userName must contain '-'");
}
---
```
#### 3.8.5 字符串检索匹配：search（RegExp）
```javascript
/* str.search(regexp) */
"micromajor163".search(/[0-9]/)  //10
"micromajor163".search(/[A-Z]/)  //-1
---
var userName = input.value;//"micromajor163"
if(userName.search(/[0-9]/) !=-1){
    alert("userName can't contain a number");
}
---
```
#### 3.8.6 字符串检索匹配：match（RegExp）
```javascript
/* str.match(regexp) */
"micormajor163".match(/[0-9]/)   //["1"]
"micromajor163".match(/[0-9]/g)  //["1","6","3"]
"micromajor163".match(/[A-Z]/)   //null
```
#### 3.8.7 字符检索替换：replace（）
```javascript
/* str.replace(regexp|substr,newSubstr|function) */
"micromajor163".replace("163","###")  //"micromajor###"
"micromajor163".replace(/[0-9]/,"#")  //"micromajor#63"
"micromajor163".replace(/[0-9]/g,"#") //"micromajor###"
"micromajor163".replace(/[0-9]/g,"#") //"micromajor"
```
#### 3.8.8 字符截取
```javascript
/* str.substring(indexA[,indexB]) */
"micromajor".substring(5,7)  //"ma"
"micromajor".substring(5)  //"major"

/* str.slice(beginSlice[,endSlice]) */
"micromajor".slice(5,7)  //"ma"
"micromajor".slice(5)  //"major"
"micromajor".slice(1,-1)  //"icromajo"
"micormajor".slice(-3)  //"jor"

/* str.substr(start[,length]) */
"micromajor".substr(5,2)  //"ma"
"micromajor".substr(5)  //"marjor"
```
#### 3.8.9 字符串拆分：split
```javascript
/* str.split([separator][,limit]) */
"micro major".split(" ")  //["micro","major"]
"micro major".split(" ",1)  //["micro"]
"micro2major".split(/[0-9]/)  //["micro","major"]
```
#### 3.8.10 大小写转换
```javascript
/* str.toLowerCase() */
"MicroMajor".toLowerCase()  //"micromajor"

/* str.toUpperCase() */
"MicroMajor".toUpperCase()  //"MICROMAJOR"
```
#### 3.8.11 字符串的连接：“+”
```javascript
"0571" + "-" + "88888888"  //"0571-88888888"
var area = areaInput.value;//0571
var tel = telInput.value;//88888888
var number = area + "-" + tel;//0571-88888888
```
#### 3.8.12 转化为字符串型：String（）
```javascript
String(163)  //"163"
String(null)  //"null"
```
#### 3.8.13 转义字符：“\”
```javascript
"micro\"major"  //"micro"major"
"micro\\major"  //"micor\major"
"micro\tmajor"  //"micro   major"
/* to be continued
```
### 3.9 对象
#### 3.9.1 创建对象
```javascript
/* use Object method:new */
var car = new Object();

/* give a 对象实例 directly */
var car = {};
```
#### 3.9.2 属性和方法
```javascript
---
var car = {
    color : "red",
    run : function(){alert("run")}
};
---
/* 访问属性和方法 */
car.color;//red
car.run();//alert("run")
car["color"];//red
car["run"]();//alert("run")

/* 增加属性和方法 */
car.type = "suv";
car.stop = function(){alert("stop")};

/* 修改属性和方法 */
car.color = "white";
car.run = function(){alert("run2")};

/* 删除属性和方法 */
delete car.color;
car.color; //undefined
```
#### 3.9.3 构造函数查询
```javascript
/* obj.constructor */
var car = {
    color : "red",
    run : function(){alert("run")}
};
car.constructor;//Object

var num = new Number(123);
num.constructor;//Number
```
#### 3.9.4 对象字符串化
```javascript
/* obj.toString() */
var num = new Number(123);
num.toString();//"123"
```
#### 3.9.5 对象值查询
```javascript
/* obj.valueOf() */
var num = new Number(123);
num.valueOf();//123
```
#### 3.9.6 对象属性存在查验
```javascript
var car = {
    color : "red",
    run : function(){alert("run")}
};
car.hasOwnProperty("color");//true
car.hasOwnProperty("logo");//false
```
### 3.10 数组
#### 3.10.1 创建数组
```javascript
/* use Object Method:new */
var array = new Array();

/* 数组实例化 */
var array = [];
var array = [1,6,3];
var array = [
    163,
    "netease",
    {color:"red"},
    [],
    true
];
---
var students = [
    {id:1,score:80},
    {id:2,score:50},
    {id:3,score:70}
];
---
```
#### 3.10.2 数组长度：arr.length
```javascript
var students = [
    {id:1,score:80},
    {id:2,score:50},
    {id:3,score:90]
];
students.length;//3

students = [];
students.length;//0
```
#### 3.10.3 获取和修改数组元素
```javascript
var students = [
    {id:1,score:70},
    {id:2,score:100},
    {id:3,score:30}
];

/* 获取数组元素 */
students[0];//{id:1,score:70}
students[3].score;//30

/* 修改数组元素 */
students[3].score = 60;
```
#### 3.10.4 搜索匹配数组元素：indexOf
```javascript
/* arr.indexOf(searchElement[,fromIndex=0]) */
var telephones = [110,120,114,1212];
telephones.indexOf(120);//1
telephones.indexOf(1212);//3
telephones.indexOf(119);//-1
```
#### 3.10.5 遍历数组元素：forEach
```javascript
/* 如果数组中是对象，可以如下操作；如果是数字需要按照3·10.17操作 */
/* arr.forEach(callback[,thisArg]) */
var editScore = function(item,index,array){
    item.score +=5;
};
students.forEach(editScore);
```
#### 3.10.6 数组倒序：reverse（）
```javascript
var telephones = [110,120,114,1212];
telephones.reverse();
telephones[0];//1212
```
#### 3.10.7 数组排序：sort（）
```javascript
/* arr.sort([compareFunction]) */
var byScore = function(a,b){
    return b.score-a.score;
};
student.sort(byScore);
//outcome to be finded out!!
//经过实验，发现时按照从大到小的顺序排序的

var studentNames = ["wq","xl","gp"];
studentNames.sort();
studentNames;//["gp","xl","wq"]
```
#### 3.10.8 添加元素：push
```javascript
/* arr.push(element1,...,elementN) */
---
var students = [
    {id:1,score:80},
    {id:2,score:90},
    {id:3,score:95}
];
---
students.push({id:4,score:99},{id:5,score:100});
---
students;
/*
[
    {id:1,score:80},
    {id:2,score:90},
    {id:3,score:95},
    {id:4,score:99},
    {id:5,score:100}
]
*/
```
#### 3.10.9 添加元素：UNshift
```javascript
/* arr.unshift(element1,...,elementN) */
---
var students = [
    {id:1,score:80},
    {id:2,score:90},
    {id:3,score:95}
];
---
students.unshift({id:4,score:99});
---
students;
/*
[
    {id:4,score:99},
    {id:1,score:80},
    {id:2,score:90},
    {id:3,score:95}
]
*/
```
#### 3.10.10 删除元素：shift
```javascript
/* arr.shift() */
---
var students = [
    {id:1,score:80},
    {id:2,score:90},
    {id:3,score:95}
];
---
students.shift();
---
students;
/*
[
    {id:2,score:90},
    {id:3,score:95}
]
*/
```
#### 3.10.11 删除元素：pop
```javascript
/* arr.pop() */
---
var students = [
    {id:1,score:80},
    {id:2,score:90},
    {id:3,score:95}
];
---
students.pop();//{id:3,score:95}
---
students;
/*
[
    {id:1,score:80},
    {id:2,score:90}
]
*/
```
#### 3.10.12 删除替换操作：splice
```javascript
/* arr.splice(index,howMany[,ele1[,...[,eleN]]]) */
---
var students = [
    {id:1,score:80},
    {id:2,score:90},
    {id:3,score:95}
];
---
students.splice(1,1,{id:4,score:99});
students;
/*
[
    {id:1,score:80},
    {id:4,score:99},
    {id:3,score:95}
]
*/

students.splice(1,1);
students;
/*
[
    {id:1,score:80},
    {id:3,score:95}
]
*/

students.splice(1,0,{id:4,score:99});
students;
/*
[
    {id:1,score:80},
    {id:4,score:99},
    {id:2,score:90},
    {id:3,score:95}
]
*/
```
#### 3.10.13 数组截取一部分：slice
```javascript
/* arr.slice(begin[,end]) */
---
var students = [
    {id:1,score:80},
    {id:2,score:90}，
    {id:3,score:95}
];
---
var newStudents = students.slice(0,2);
newStudents;
/*
[
    {id:1,score:80},
    {id:2,score:90}
]
*/

var newStudents = students.slice(0);
newStudents;
/*
[
    {id:1,score:80},
    {id:2,score:90},
    {id:3,score:95}
]
*/
```
#### 3.10.14 数组连接：concat
```javascript
/* arr.concat(value1,...,valueN) */
---
var students = [
    {id:1,score:80},
    {id:2,score:90},
    {id:3,score:95}
];
var students1 = [
    {id:4,score:99},
    {id:5,score:100}
];
---
var newStudents = students.concat(students1);
newStudents;
/*
[
    {id:1,score:80},
    {id:2,score:90},
    {id:3,score:95},
    {id:4,score:99},
    {id:5,score:100}
]
*/
```
#### 3.10.15 字符串分割得到数组：split
```javascript
/* str.split(seperater); */
"wuq@163.com;gp@163.com;xl@163.com".split(",");
//["wuq#163.com","gp@163.com","xl@163.com"]
```
#### 3.10.16 数组连接成字符串：join
```javascript
/* array.join(connecter); */
var emails = ["wuq@163.com","gp@163.com","xl@163.com"];
emails.join(";");
//"wuq@163.com;gp@163.com;xl@163.com"
```
#### 3.10.17 遍历数组操作：forEach（function）
```javascript
/* array.forEach(function()); */
var scores = [60,70,80,90];
var newScore = [];
var addScore = function(item,index,array){
    newScore.push(item+5);
};
scores.forEach(addScore);
newScore;
//[65,75,85,95]
```
#### 3.10.18 遍历数组操作：map
```javasript
/* array.map(function()); */
var scores = [60,70,80,90];
var addScore = function(item,index,array){
    return item+5;
};
var arr2 = scores.map(addScore);
//经过map遍历操作过的item需要存在一个新的arr2中才能正常访问
```
#### 3.10.19 渐次操作：reduce
```javascript
/* arr.reduce(callback,[initialValue]); */
var students = [
    {id:1,score:80},
    {id:2,score:90},
    {id:3,socre:95}
];
var sum = function(previousResult,item,index,array){
    return previousResult + item.score;
};
students.reduce(sum,0);//265
```
### 3.11 函数
#### 3.11.1 函数语法
```javascript
/*  函数的一般形式和调用方法如下 */
---
function 函数名([形参列表]){
    执行代码;
};
函数名([实参列表]);
---
function add(number0,number1){
    var sum = number0 + number1;
    return sum;
};
var x = add(2,3);//5
```
#### 3.11.2 函数的定义
```javascript
/* 函数申明 */
function add(number0,number1){
    var sum = number0 + number1;
    return sum;
}

/* 函数表达式 */
var add = function(number0,number1){
    var sum = number0 + number1;
    return sum;
}

var x = add(3,4);//7
```
#### 3.11.3 函数的调用
```javascript
/* 函数名([实参列表]) */
var add = function(number0,number1){
    var sum = number0 + number1;
    return sum;
}

var x = add(7,9);//16
```
#### 3.11.4 函数的参数
```javascript
/* 参数为原始类型：值传递 */
function increment(number){
    number = number + 1;
    return number;
};
var a = 1;
var x = increment(a);
//x=2,但是a=1,没有变；

/* 参数为对象类型：引用传递 */
var ageIncrement = function(person){
    person.age = person.age + 1;
    return person;
};
var jerry = {name:"jerry",age:1};
var x = ageIcrement(jerry);
//x={name:"jerry",age:2},而且jerry也已经变成了jerry = {name:"jerry",age:2};

/* 任意个数字的和 */
var sum = function(){
    var length = arguments.length,
    sum = 0,
    parameter,
    for(var i = 0;i<length;i++){
        parameter = argument[i];
        sum += parameter;
    }
    return sum;//这里return一定在for循环之外的哦！！
};
add(1,3);//4
add(3,4,8,9);//24
```
#### 3.11.5 作用域
```javascript
/* example one */
var yaoming = {
    name:"姚明",
    gerder:1
};
function football(){
    var yaoming = {
        name:"要命",
        gender:0
    };
    yaoming.name = "耀名";
    yaoming.gender = 3;
}
football();
yaoming;
//{name:"姚明",gender:1},因为football()函数只把该函数内部的yaoming变为{name:"耀名",gender=3}

/* example two */
var yaoming = {
    name:"姚明",
    gender:1
};
function football(){
    yaoming.name = "耀名";
    yaoming.gender = 4;
}
football();
yaoming;
//{name:"耀名",gender:4},这里football()函数中作用的对象yaoming，只能是最前面的yaoming。
```
#### 3.11.6 作为对象的属性
```javascript
/* 函数作为对象的属性，使得对象有一定的行为 */
var point = {
    x: 1,
    y: 1,
    move: function(stepX,stepY){
        point.x += stepX;
        point.y += stepY;
    }
};
point.move(2,1);
//point.x = 3;point.y = 2;

/* 对象属性函数中的对象本身可以用this来代替，上面的point对象可以改写如下 */
var point = {
    x: 1,
    y: 1,
    move: function(stepX,stepY){
        this.x += stepX;
        this.y += stepY;
    }
};
point.move(2,1);
//point.x = 3;point.y = 2;
```
#### 3.11.7 构造函数
```javascript
/* Point */
function Point(x,y){
    this.x = x;
    this.y = y;
    this.move = function(stepX,stepY){
        this.x +=stepX;
        this.y +=stepY;
    }
}

var point = new Point(1,1);
var point1 = new Point(2,2);
var point2 = new Point(3,3);

/* Car */
function Car(type,color){
    this.type = type;
    this.color = color;
    this.status = "stop";
    this.light = "on";
    console.log(this);//Car{type:"benz",color:"red",status:"stop",light:"off"}
}
Car.prototype.start =function(){
    this.status = "driving";
    this.light = "on";
    console.log(this.type+" is "+this.status+" with light "+this.light);
}
Car.prototype.stop = function(){
    this.status = "stop";
    this.light = "off";
    console.log(this.type+" is "+this.status+" with light "+this.light);
}
var benz = new Car('benz','red');
benz.start();//benz is driving with light on
benz.stop();//benz is stop with light off
```
#### 3.11.8 原型
```javascript
/* 用原型的方法，为构造函数上添加属性 */
function Point(x,y){
    this.x = x;
    this.y = y;
}
Pint.prototype.move = function(stepX,stepY){
    this.x += stepX;
    this.y += stepY;
};
var point = new Point(1,1);
point.move(2,3);
//point = {x:3,y:4}
```
### 3.12 Date日期
#### 3.12.1 创建日期
```javascript
/* 当前时间 */
new Date();

/* any certain date */
/* new Date(year,month[,day[,hour[,minutes[,seconds[,milliseconds]]]]]) */

new Date(1978,11);//1978-12-01 00:00:00
/* Date函数中月份是‘0-11’，所以显示的月份要比代码中的月份数+1；*/

new Date(2001,8,11);//2001-9-11 00:00:00
new Date(2015,7,20,14,57,18);//2015-8-20 14:57:18
```
#### 3.12.2 时间分解
```javascript
var date = new Date(2015,7,20,14,57,18);//2015-08-20 14:57:18

date.getFullYear();//2015
date.getMonth();//7
date.getDate();//20
date.getHours();//14
date.getMinutes();//57
date.getSeconds();//18
```
#### 3.12.3 时间格式化
```javascript
/* 让一个时间在页面上按照约定俗成的样式显示 */
var date = new Date(2015,7,20,14,57,18);
function format(date){
    ---这样是否正确待确认！！！//经过实验验证，要在条件语句前面加上“return”才好使
    var padding = function(aim){
        aim<=9?'0'+aim:aim;
    };
    ---
    return date.getFullYear()+'-'
    + padding(date.getMonth()+1)+'-'
    + padding(date.getDate())+' '
    + padding(date.getHours())+':'
    + padding(date.getMinutes())+':'
    + padding(date.getSeconds());
}

/* 设置特定的时间部分 */
var date = new Date(2015,7,20,14,57,18);//2015-08-20 14:57:18
date.setFullYear(2046);//2046-08-20 14:57:18
date.setMonth(2);//2046-03-20 14:57:18
date.setDate(15);//2046-03-15 14:57:18
date.setHours(8);//2046-03-15 08:57:18
date.setMinutes(16);//2046-03-15 08:16:18

date.setDate(35);//2046-04-19 08:16:18
date.setHours(100);//2046-04-22 12:16:18
```
### 3.12.4 求一个月的天数
```javascript
/* 需要求一个月有多少天，我们可以设置date下个月的第0天，来获取 */
new Date(2001,2,0);//2001-02-28 00:00:00 ,即2001年2月有28天；
new Date(2001,3,0);//2001-03-31 00:00:00 ,即2001年3月有31天；
```
#### 3.12.5 显示时间和系统储存时间的转换
```javascript
/* Date-->Number */
var dte = new Date(2015,7,20,14,57,18);//2015-08-20 14:57:18
date.getTime();//1440053838000 这个数字为该日期距离1970-01-01 00:00:00的毫秒数；

/* Number-->Date */
new Date(1440053838000);//2015-08-20 14:57:18
```
### 3.13 正则表达式RegExp
#### 3.13.1 RegExp
```javascript
/* 描述字符串规则的表达式 */
/* /pattern/attrs */
new RegExp(pattern,attrs)
/13566668888/
/jerry/i
```
#### 3.13.2 测试正则表达式和指定字符是否匹配
```javascript
/* regexObj.test(str) */
/13566668888/.test('13566668888');//true
/13566668888/.test('1356666888');//false
/13566668888/.test('x1356668888')//true
/13566668888/.test('1356666F8888')//false /* 字符段必须是一整段的,不能有间隔 */
```
#### 3.13.3 锚点
```javascript
/* 
用来匹配一个位置；
'^':起始位置； /^http:/
'$':结束位置； /\.jpg$/
'\b':单词边界； /\bis\b/
*/

/^13566668888$/
/^13566668888$/.test('x13566668888y');//false
/^13566668888$/.test('13566668888');//true
```
#### 3.13.4 字符类
```javascript
/*
匹配一类字符中的一个；
- [abc] :a||b||c
- [0-9] :一个数字
- [^0-9] :一个非数字的字符-->只要有一个非数字的字符就为true
- [a-z] :一个字母
- . :任意字符（换行除外）
*/
/^[0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9]$/.test('15528332668');//true
```
#### 3.13.5 元字符
```javascript
/*
》》一些具有特殊意义的字符《《
    - ^ / $ / \b
    - \d : [0-9]
    - \D : [^\d]
    - \s : 空白符
    - \S : [^\s]
    - \w : [A-Za-z0-9]
    - \W : [^\w]
*/
/^\d\d\d\d\d\d\d\d\d\d\d$/.test('15528332668');//true
```
#### 3.13.6 量词
```javascript
/*
》》字符出现的次数《《
    - {m,n} : m至n次
    - * : {0,}
    - ? : {0,1}
    - + : {1,}
*/
/^1\d{10}$/.test('13513238869');//true
```
#### 3.13.7 转义字符
```javascript
/* 如果需要匹配的字符是元字符，则需要转义 */
/^http:\/\//
/@163\.com$/
```
#### 3.13.8 多选分支
```javascript
/* 或 */
/thi(c|n)k/  === /thi[cn]k/
/\.(jpg|png|jpeg|gif)$/
```
#### 3.13.9 捕获
* 捕获，是指保存匹配到的字符串，以后再用；
    * () : 捕获;  `/(.+)@(163|126|188)\.com$/`
    * (?:) : 不捕获;  `/(.+)@(?:163|126|188)\.com$/`
* 使用
    * \$1,\$2,...
    * API参数或者返回值

#### 3.13.10 获取匹配的字符
![netId](https://github.com/Wanlin-Lu/Front-end-knowledge-summary/blob/master/images/3.13.10.png)
```javascript
/* 有时需要使用一个URL(如上图)的不同部分，就需要分段匹配获取 */
/* str.match(regexp) */
var url = 'http://blog.163.com/album?id=1#comment';
var reg = /(https?:)\/\/([^\/]+)(\/[^\?]*)?(\?[^#]*)?(#.*)?/;
var arr = url.match(reg);
var protocol = arr[1];
var host = arr[2];
var pathname = arr[3];
var search = arr[4];
var hash = arr[5];
//结果待验证呀！！！
```
#### 3.13.11 替换一个字符
```javascript
/* str.replace(regexp/substr,replacement) */
var str = 'The price of tomato is 5,the price of apple is 10.';

str.replace(/(\d+)/,'$1.00');
//'The price of tomato is 5.00,the price of apple is 10.'

str.replace(/(\d+)/g,'$1.00');//加上的'g'，意思是全局模式
//'The price of tomato is 5.00,the price of apple is 10.00.'
```
#### 3.13.12 详情检索
```javascript
/* 
regexpObj.exec(str) 
- 更详尽的结果：index
- 过程的状态：lastIndex
*/
//怎么用还待研究。。。
```
### 3.14 JSON
#### 3.14.1 JSON表达式
```javascript
/* JSON:JavaScript Object Notaion */
---
var jerry = {
    name: 'jerry',
    age: 1
};
"" + jerry;
---
object:'{name:'jerry',age:1}'
JSON:'{"name":"jerry","age":1}'
```
#### 3.14.2 JS-->JSON
```javascript
/* JSON.stringify(value[,replacer[,space]]) */
---
var user = {
    id:1,
    nick:"deadbug",
    avatar:"1.jpg",
    tags:null,
    authed:false
};
---
JSON.stringify(user);
//'{"id":1,"nick":"deadbug","avatar":"1.jpg","tags":null,"authed":false}'
```
#### 3.14.3 JSON-->JS
```javascript
/* JSON.parse(text[,reviver]) */
---
var userJson = {
    "id":1,
    "nick":"deadbug",
    "avatar":"1.jpg",
    "tags":null,
    "authed":false
};
---
var user = JSON.parse(userJson);
user;
//'{id:1,nick:"deadbug",avatar:"1.jpg","tags":null,"authed":false}'
```

### 3.15 类型进阶
#### 3.15.1 JS的六种类型
* JS类型
    * 原始（值）类型
        * Undefined :`undefined`
        * Null :`null`
        * Boolean :`true`,`false`
        * String :`"hello,world"`
        * Number :`123`,`var num1 = new Number();`
    * 对象（引用）类型
        * Object :`var obj = {};`,`var arr = [];`,`var date = new Date();`

#### 3.15.2 JS的对象类型
* JS对象类型
    * 原生对象（即ECMA规定的对象）
        * 构造函数
            * Boolean
            * String
            * Number
            * Object
            * Function
            * Array
            * Date
            * RegExp
            * Error
        * 对象
            * Math
            * JSON
            * 全局对象
            * arguments
    * 宿主对象（浏览器提供的对象）
        * window
        * navigator
        * document
        * ...
    * 浏览器扩展对象（特有浏览器的专有对象）
        * ActiveXObject
        * XML
        * Debug
        * Script
        * VBArray
        * ...

#### 3.15.3 原始类型和对象类型的区别
##### A 栈内存和堆内存
```javascript
var a;
var b = null;
var c = true;
var d = 123;
var e = "hello";
var f = {a:1};
/* 以上变量的储存方式如下图所示 */
```
![栈内存和堆内存](https://github.com/Wanlin-Lu/Front-end-knowledge-summary/blob/master/images/3.15.3-1.png)

##### B 原始类型和对象类型复制后的差异及分析：
```javascript
var num1 = 123;
var num2 = num1;
num1 = 1;
num2;//123

var obj1 = {a:1};
var obj2 = obj1;
obj1.a = 2;
obj2.a;//2
```
之所以会有上面的结果，原因如下图：<br>
![栈堆复制](https://github.com/Wanlin-Lu/Front-end-knowledge-summary/blob/master/images/3.15.3-2.png)
#### 3.15.4 类型转换
##### A 隐式类型转换
隐式类型转换的结果一览表：<br>
![隐式类型转换结果](https://github.com/Wanlin-Lu/Front-end-knowledge-summary/blob/master/images/3.15.4-1.png)
##### B 显示类型转换方法
```javascript
- Number();
- String();
- Boolean();
- parseInt(),parseFloat
- !,!!;

ret.innerText = 10 + Number(num.value);
```
#### 3.15.5 类型识别
类型识别的方法有：`typeof`,`instanceof`,`Object.prototype.toString.call`,`constructor`;
##### typeof
```javascript
typeof "jerry";//"string"
typeof 12;//"number"
typeof true;//"boolean"
typeof undefined;//"undefined"
typeof null;//"objct"这里！！！
typeof {name:"jerry"};//"object"
typeof function(){};//"function"这里！！！
typeof [];//"object"
typeof new Date;//"object"
typeof /\d/;//"object"
function Person(){};
typeof new Person;//"object"
---
/* 
typeof总结：
    - 标准类型除了Null不能识别之外，其他4种都可以正确识别；
    - 对象类型除了Function能识别之外，其他都只能识别为"object",而不能具体识别出； 
*/
```
##### instanceof
```javascript
//能够判别内置对象类型
[] instanceof Array;//true
/\d/ instanceof RegExp;//true
//不能识别原始类型
1 instanceof Number;//false
"jerry" instanceof String;//false
//能够判别自定义对象类型及父子类型
function Point(x,y){
    this.x = x;
    this.y = y;
}
function Circle(x,y,r){
    Point.call(this,x,y);
    this.radius = r;
}
Circle.prototype = new Point();
Circle.prototype.constructor = Circle;
var c = new Circle(1,1,2);
c instanceof Circle;//true
c instanceof Point;//true
/*
instanceof总结：
    - 可以正确判断内置对象类型；
    - 不能判别原始类型；
    -可以判别自定义对象类型；
*/
```
##### Object.prototype.toString.call
```javascript
---
function type(obj){
    return Object.prototype.toString.call(obj).slice(8,-1);
}
---
type(1);//"Number"
type("abc");//"String"
type(true);//"Boolean"
type(undefined);//"Undefined"
type(null);//"Null"
type([]);//"Array"
type({});//"Object"
type(new Date);//"Date"
type(/\d/);//"RegExp"
type(function(){});//"Function"
function Point(x,y){
    this.x = x;
    this.y = y;
}
type(new Point(1,2));//"Object"这里！！
/* 
Object.prototype.toString.call总结：
    - 可以识别标准类型及内置（build-in）对象类型；
    - 不能识别自定义对象类型；
```
##### constructor
```javascript
//判断原始类型
"jerry".constructor === String;   //true
(1).constructor === Number;   //true
true.constructor === Boolean;   //true
({}).constructor === Object;   //true
//判断内置对象类型
new Date().constructor === Date;   //true
[].constructor === Array;   //true
//判断自定义对象
function Person(name){
    this.name = name;
}
new Person("jerry").constructor === Person;   //true
/*
constructor总结：
    - 可以判别标准类型，Undefined和Null除外；
    - 判别内置对象类型；
    - 判别自定义对象类型；
*/

/* 下面是获取constructorName的方法 */
fuction getConstructorName(obj){
    return (obj===undefined||obj===null)?obj:(obj.constructor&&obj.constructor.toString().match(/function\s*([^<]*)/)[1]);
}
---
(123).constructor.toString();//"function Number(){native code}"
.match(/function\s*([^(]*)/)[1];//"Number"
---
```
##### To date
```javascript
/*
* 输入格式：
* ‘2015-08-05’
* 1428744815232
* {y:2015,m:8,d:5}
* [2015,8,5]
* 返回格式：Date
* 要求：function toDate(param){}
*/

function doDate(param){
    if(typeof(param) == 'string'||typeof(param) == 'number'){
        return new Date(param);
    }
    if(param instanceof Array){
        var date = new Date(0);
        date.setYear(param[0]);
        date.setMonth(param[1]-1);
        date.setDate(param[2]);
        return date;
    }
    if(typeof(param) = "object"){
        var date = new Date(0);
        date.setYear(param.y);
        date.setMonth(param.m-1);
        date.setDate(param.d);
        return date;
    }
    return -1;
}
```
### 3.16 函数进阶
#### 3.16.1 函数定义的三种方法
```javascript
/* 函数声明 */
fuction add(i,j){
    return i+j;
}
---
add1(1);//11
function add1(i){
    console.log("函数声明："+(i+1));
}
function add1(i){
    console.log("函数声明："+(i+10));
}
add1(2);//12
---

/* 函数表达式 */
var add = function(i,j){
    return i+j;
};
---
// add2(1);//add2 is not a function(程序无法继续运行下去,注释掉才可以)
var add2 = function(i){
    console.log("函数表达式："+(i+2));
}
add2(1);//3
var add2 = function(i){
    console.log("函数表达式："+(i+10));
}
add2(3);//13
---

/* 函数实例化 */
var add = new function("i","j","return (i+j)");
---
var add3 = new Function("i","console.log('函数实例化:'+(i+20))");
add3(3);//23

var person = {name:"刘德华",age:50};
(function(){
    var person = {name:"刘德华",age:30};
    var func = new Function("console.log(person.name+person.age+'years old');");
    func();
})();//刘德华50years old--->只能访问本地和全局作用域
---
/*
* 函数声明定义的函数，在定义位置之前就可以引用；而函数表达式和函数实例化定义的函数就不行；
* 浏览器在执行代码前有一个‘预解析’的步骤，在‘预解析’的时候‘函数声明’会被提到前面去；

* 浏览器执行代码顺序：‘预解析’--->‘执行’；

* 函数声明定义函数的特点
    - 1.函数定义会被前置；
    - 2.重复定义函数时，最后一次定义有效；
* 函数实例化定义函数的特点：
    - 定义的函数只能访问本地作用域和全局作用域；
*/
```
#### 3.16.2 函数调用
* 函数调用方式
    * 直接函数调用模式；add(1);
    * 方法调用模式；
    * 构造函数调用模式；new Function(...);
    * apply(call)调用模式；
```javascript
/* Function.prototype.apply */
function Point(x,y){
    this.x = x;
    this.y = y;
}
Point.prototype.move = function(x,y){
    this.x += x;
    this.y += y;
}
var p = new Point(0,0);
p.move(2,2);
P;//(2,2)

var circle = {x:1,y:1,r:1};
p.move.apply(circle,[2,1]);
//{x:3,y:2,r:1}
```
##### A 函数调用模式的区别--this
```javascript
/* 函数调用模式 */
function add(i,j){
    console.log(this);//window
    console.log(arguments);//[1,2]
    var sum = i+j;
    console.log(sum);//3
    (function(){
        console.log(this);//window
    })()
    return sum;
}
add(1,2);

/* 方法调用 */
var mynumber = {
    value:1,
    add: function(i){
        console.log(this);//Object{value:1,add(){}}
        this.value +=i;
    }
}
mynumber.add(1);//{value:2,add(){}}


var mynumber = {
    value:1,
    add: function(i){
        console.log(this);//{value:1,add(){}}
        var helper = function(i){
            console.log(this);//window
            this.value +=i;
        }
        helper(i);
    }
}
mynumber.add(1);

/* apply(call)调用 */
var mynumber = {
    value:1,
    add: function(i){
        this.value +=i;
        console.log(this);
    }
}
var younumber = {
    value:10,
}
mynumber.add.apply(younumber,[3]);//{value:13}
mynumber.add.call(younumber,3);//{value:16}
```
* 函数调用模式
    - this指向全局对象
* 方法调用模式
    - this指向调用者
* 构造函数调用模式
    - this指向被调用者
* apply（call）调用模式
    - this指向第一个参数

##### B 函数调用--arguments
```javascript
Array-like
- arguments[index]
- arguments.length

/* arguments转数组 */
(function(){
    var args = Array.prototype.slice.apply(arguments);
    args.forEach(function(item){
        console.log(item);
    })
})(1,2,3,4,5)

/* arguments.callee的使用(在ES5严格模式中已经取消了) */
console.log(
    (function(i){
        if (i==0) {
            return 1;
        }
        return i*arguments.callee(i-1);
    })(5)
);//120

function create(){
    return function(i){
        if (i==0) {
            return 1;
        }
        return i*arguments.callee(i-1);
    };
}
var result = create()(6);
console.log(result);//720

/* 不使用arguments.callee的递归法 */
function factorial(i){
    if(i==0){
        return 1;
    }
    return i*factorial(i-1);
}
console.log(factorial(5));//120
```
##### C 函数传参
```javascript
//原始类型按值传递
var count = 1;
var addone = function(num){
    num +=1;
    return num;
}
var ret = addone(count);
console.log(ret);//2
console.log(count);//1

//对象类型按共享传递
var count = {a:1,b:1};
var addone = function(obj){
    obj.a +=1;
    obj.b +=1;
    return obj;
}
var ret = addone(count);
console.log(ret);//Object {a:2,b:2}
console.log(count);//Object {a:2,b:2}

var count = {a:1,b:1};
var addone = function(obj){
    obj={a:2,b:2};
    return obj;
}
var ret = addone(count);
console.log(ret);//Object {a:2,b:2}
console.log(count);//Object {a:1,b:1}
```
* 按值传递-- call by value ;(原始类型是按值传递）
* 按引用传递-- call by reference ;()
* 按共享传递-- call by sharing;（JS对象类型的传递方式）

JS对象类型的传递方式如下图所示：<br>
![对象类型的传递模式](https://github.com/Wanlin-Lu/Front-end-knowledge-summary/blob/master/images/3.16.2.c.png)

综上：在JS中`原始类型`是`按值传递`的，对`象类型`是`按共享传递`的。

#### 3.16.3 闭包
##### A 什么是闭包
```javascript
(function(){
    var a = 1;
    (function(){
        console.log(a);
        debugger;
    })()
})();

/* 如上面的函数所示，闭包就是子函数中用到了父函数中的变量 */
```
##### B 闭包的功能
```javascript
/* 保存函数的执行状态 */
var arr = ['c','f','h','o'];
var str = 'ab4de8g1ijklmn9';
console.log(str);
---
var func = (function(){
    // count变量会保存在闭包作用域内，表示func被调用的次数（即正在替换第几个字符）；
    var count = 0;
    return function(){
        return arr[count++];
    }
})();
---
str = str.replace(/\d/g,func);
console.log(str);

/* 封装 */
var Car = function(type){
    var status = "stop",
        light = "off";
    return {
        type: type,
        start: function(){
            status = "driving";
            light = "on";
        },
        stop: function(){
            status = "stop";
            light = "off";
        },
        getStatus: function(){
            console.log(type + " is " + status + " with lingt " + light + ".");
        }
    }
}

var audi = new Car("audi");
audi.start();
audi.getStatus();
audi.stop();
audi.getStatus();
//在练习的时候要看一下原始笔记，看封装的效果

/* 性能优化 */
---
/* 非闭包函数 */
function sum(i,j){
    var add = function(i,j){
        return i+j;
    }
    return add(i,j)
}
---
var startTime = new Date();
for(var i = 0;i<1000000;i++){
    sum(1+1);
}
var endTime = new Date();
console.log(endTime - startTime);
//195

---
/* 闭包函数 */
var sum = (function(){
    var add = function(i,j){
        return i+j;
    }
    return function(i,j){
        add(i,j);
    }
})()
---
var startTime = new Date();
for(var i = 0;i<1000000;i++){
    sum(1+1);
}
var endTime = new Date();
console.log(endTime - startTime);
//17

/* 性能优化2 */
//普通递归函数和使用闭包记录调用返回结果的递归函数调用次数对比
//普通递归函数
var factorial = (function(){
    var count = 0;
    var fac = function(i){
        count++;
        if(i==0){
            console.log('调用次数：'+count);
            return 1;
        }
        return i*fac(i-1);
    }
    return fac;
})();
for(var i=0;i<10;i++){
    console.log(factorial(i));
}
//1.3.6.10.15.21.28.36.45.55

//使用闭包记录调用返回结果的递归函数--记忆函数
var factorial = (function(){
    var memo = [1];
    var count = 0;
    var fac = function(i){
        count++;
        var result = memo[i];
        if(typeof result ==='number'){
            console.log('调用次数:'+count);
            return result;
        }
        result = i*fac(i-1);
        memo[i] = result;
        return result;
    }
    return fac;
})();
for(var i=0;i<10;i++){
    console.log(factorial(i));
}//1.3.5.7.9.11.13.15.17.19
//对于该函数理解还不到位，日后需要回来研究。。。
```
#### 3.16.4 First-class function
* 什么是First-class function？
    - 该类型的值可以作为`函数的参数`和`返回值`，也可以`赋给变量`；
* 有哪些功能
    - 函数作为参数：`异步回调函数Ajax`;
    - 函数作为返回值：`curry化`；
```javascript
/* Function.prototype.bind */
function Point(x,y){
    this.x = x;
    this.y = y;
}
Point.prototype.move = fucntion(x,y){
    this.x +=x;
    this.y +=y;
}
var p = new Point(0,0);
console.log(p);//Point {x:0,y:0}
p.move(2,2);
concole.log(p);//Point {x:2,y:2}

var circle = {x:1,y:1,r:1};
var circlemove = p.move.bind(circle,2,2);
circlemove();
console.log(circle);//Object {x:3,y:3,r:1}
var circlemove1 = p.move.bind(circle);
circlemove1(3,3);
console.log(circle);//Object {x:4,y:4,r:1}

point.move.apply(circle,[3,3]);//Object {x:4,y:4,r:1}
point.move.call(circle,4,4);//Object {x:5,y:5,r:1}

/* bind的兼容性实现 */
//检查是否有定义
if(!Function.prototype.bind){
    Function.prototype.bind = function(thisObj){
        //获取函数本身
        var _func = this,
            //获取函数调用者（bind方法的第一个参数）
            _this = thisObj,
            //获取函数绑定的采纳数列表
            _params = Array.prototype.slice.call(arguments,1);
        //返回一个函数，外部变量通过持有这个函数医用保存_func,_this,_params这三个闭包变量，并随时执行函数以调用下面的语句。
        return function(){
            var _localParams = Array.prototype.slice.call(arguments);
                _params = _params.concat(_localParams);
                _func.apply(_this,_params);//实现函数的调用
        }
    }
}

/* 简单柯里化 */
var sum = function(a,b,c){
    return a+b+c;
}
////最简单的柯里化sum函数
var sum_curry = function(a){
    return function(b,c){
        return a+b+c;
    }
}
//this function is wrong, tally wrong!!!!

/*
泛柯里化
从更上层的角度去理解，柯里化允许和鼓励你将一个复杂过程分割成一个个更小的更容易分析的过程（这些小的逻辑单元将更容易被理解和测试），最后这样一个难于理解的复杂过程将变成一个个小的逻辑简单的过程的组合。
*/
```
### 3.17 原型进阶
#### 3.17.1 原型的定义
* 类：`抽象`--->`具体`
* 原型：`具体`--->`具体`
    - 原型使用方法：`原型对象`--->`新对象`

#### 3.17.2 设置对象的原型

##### Object.create
```javascript
//定义原型对象
var landRover ={
    name: 'landRover',
    start: function(){
        console.log('%s start',this.logo);
    },
    run: function(){
        console.log('%s running',this.logo);
    },
    stop: function(){
        console.log('%s stop',this.logo);
    }
}
/* Object.create */
var landWind = Object.create(landRover);//是否为Car.create(landRover)???
landWind.logo = "landWind";
var landCruiser = Object.create(landRover);//是否为Car.create(landCruiser)???
landCruiser.logo = "landCruiser";
landWind.start();//启动
```
![object.create](https://github.com/Wanlin-Lu/Front-end-knowledge-summary/blob/master/images/3.17.2-1.png)
##### 构造函数
```javascript
//car构造函数
function Car(logo){
    this.logo = logo || 'unknown name';
}
//设置Car的prototype属性
car.prototype = {
    start: function(){
        console.log('%s start',this.logo);
    },
    run: function(){
        console.log('%s running',this.logo);
    },
    stop: function(){
        console.log('%s stop',this.logo);
    }
}
/* 前面使用prototype设置原型，这里用new创建对象 */
var landRover = new Car('landRover');
var landWind = new Car('landWind');
landRover.start();//调用方法
```
![构造函数](https://github.com/Wanlin-Lu/Front-end-knowledge-summary/blob/master/images/3.17.2-2.png)
#### 3.17.3 原型链实例
```javascript
//Car构造函数
function Car(logo){
    this.log = logo || "unknown name";
}
//设置Car的prototype属性
Car.prototype = {
    start: function(){
        console.log('%s start',this.logo);
    },
    run: function(){
        console.log('%s running',this.logo);
    },
    stop: function(){
        console.log('%s stop',this.logo);
    }
}

//landRover构造函数
function LandRover(serialno){
    this.serialno = serialno;
}
//设置LandRover的prototype属性
LandRover.prototype = new Car('landRover');

//创建LandRover对象
var landRover1 = new LandRover(10000);
var landRover2 = new LandRover(10001);

console.log(landRover1.serialno);
console.log(landRover1.start());
```
上面代码的原型链如下图：<br>
![原型链](https://github.com/Wanlin-Lu/Front-end-knowledge-summary/blob/master/images/3.17.3-1.png)

通过原型链找到调用的方法：<br>
![原型链](https://github.com/Wanlin-Lu/Front-end-knowledge-summary/blob/master/images/3.17.3-2.png)

通过原型链确认对象是否自有属性：<br>
![原型链](https://github.com/Wanlin-Lu/Front-end-knowledge-summary/blob/master/images/3.17.3-3.png)

完整的原型链图：<br>
![原型链](https://github.com/Wanlin-Lu/Front-end-knowledge-summary/blob/master/images/3.17.3-4.png)
### 3.18 变量作用域进阶
变量的生命周期和作用范围：
#### 3.18.1 静态作用域
* 静态作用域
    - 又称为词法作用域；
    - 由程序定义的位置决定；
```javascript
var x=10;
function foo(){
    alert(x);
}
function bar(){
    var x=20;
    foo();
}
bar();
// 那么bar（）；的值应该是多少呢？我认为应该是20；(结果是10，因为foo函数外面就是全局作用域）
```
![静态作用域](https://github.com/Wanlin-Lu/Front-end-knowledge-summary/blob/master/images/3.18.1.png)
#### 3.18.2 动态作用域
* 动态作用域
    - 程序运行时刻决定；
```javascript
var x=10;
function foo(){
    alert(x);
}
function bar(){
    var x=20;
    foo();
}
bar();
//应该是20
```
![动态作用域](https://github.com/Wanlin-Lu/Front-end-knowledge-summary/blob/master/images/3.18.2.png)
#### 3.18.3 JS变量作用域
* JS使用静态作用域；
* JS没有块级作用域（全局作用域、函数作用域）；
* ES5中使用`词法环境`管理静态作用域；

![词法环境](https://github.com/Wanlin-Lu/Front-end-knowledge-summary/blob/master/images/3.18.3.png)

词法环境记录初始化时声明提前；具体的词法环境执行过程还待研究！！！
```javascript
/* 三个person定义在三个层级的函数上，从内到外执行 */
var person = {name:"刘德华", age:50};
(function(){
  // var person = {name:"刘德华", age:30};
  (function() {
    // var person = {name:"刘德华", age:10};
    console.log(person.name+person.age+"岁");
  })()
})();
```
词法环境--with<br>
![词法环境-with](https://github.com/Wanlin-Lu/Front-end-knowledge-summary/blob/master/images/3.18.3-1.png)

词法环境--try catch<br>
![词法环境-try catch](https://github.com/Wanlin-Lu/Front-end-knowledge-summary/blob/master/images/3.18.3-2.png)
### 3.19 闭包进阶
#### 3.19.1 闭包的定义
* 闭包由函数和与其相关的引用环境的组合而成；
* 闭包允许函数访问其引用环境中的变量（又称自由变量）；
* 广义来说，所有的JS函数都可以称为闭包，因为JS函数在创建时就保存了当前的词法环境；

**闭包对我来说还是很模糊的一个概念，需要深入研究**

#### 3.19.2 闭包的应用
```javascript
/* 保存现场 */
function addHandlers(nodes){
    function helper(i){
        return function(){
            alert(i);
        }
    }
    for (var i = 0;i<nodes.length;i++){
        node[i].onclick = helper(i);
    }
}
//上面的函数中，node[i]被点击后，点击的次数会被helper()函数记录下来

/* 封装 */
var observer = (function(){
    var observerList = [];
    return {
        add: function(obj){
            observarList.push(obj);
        },
        empty: function(){
            observarList = [];
        },
        getCount: function(){
            return observarList.length;
        },
        get: function(){
            return observarList;
        }
    }
})();
```
### 3.20 面向对象编程
这一部分的内容，等以后再补充，现在有点吃力呀！（2018.03.23）
#### 3.20.1 全局变量
#### 3.20.2 信息隐藏

### 3.21 ES6新特性
#### 3.21.1 let和const
##### 3.21.1.1 ES6新的变量定义关键字-->`let`
```js
//var 的变量提升
var arr = [];
for(var i;i<10;i++){
    arr[i]=function(){
        alert(i)
    }
}
arr[8];//预期为8，其实输出为10；

var arr = [];
for(let i;i<10;i++) {
    arr[i] = function() {
        alert(i)
    }
}
arr[8];//8
```
`let`声明的变量只在自己所在的块级作用域中起作用。
>任何一对花括号（这玩意：{ }）中的语句都属于一个块，在花括号里面用let定义的所有变量在花括号外都是不可见的，我们称之为块级作用域。
```js
var a = 1;
(function(){
    alert(a); //undefined
    var a = 2;
})()
//上面代码实际执行顺序
var a = 1;
(function(){
    var a;
    alert(a);//执行时a还没有被赋值
    a = 2;
})()

var a = 1;
(function(){
    alert(a);//error :a is not defined
    let a = 2;
})()
```
总结：
>用let声明变量只在块级作用域起作用，适合在for循环使用，也不会出现变量提升现象。同一个代码块内，不可重复声明的相同变量，不可重复声明函数内的参数。

##### 3.21.1.2 ES6新增关键字`const`
const是constant（常量）的缩写，const和 let一样，也是用来声明变量的，但是const是专门用于声明一个常量的，顾名思义，常量的值是不可改变的。
```js
//不可修改
const Name = 'zhangsan';
Name = 'lisi';//错误

//只所用于块级作用域
if(1){
    const Name = 'zhangsan';
}
alert(Name);//wrong

//不存在变量提升，必须先声明后使用，和let一样
if(1){
    alert(Name);//wrong
    const Name = 'zhangsan';
}
//不可重复声明同一个变量
var Name = "zhangsan";
const Name = "lisi";//wrong

//声明后必须赋值
const Name;//wrong
```
对象赋值
>传址：在赋值过程中，变量实际上存储的是数据的地址（对数据的引用），而不是原始数据或者数据的拷贝。
```js
const Person = {"name":"zhangsan"};
Person.name = "lisi";
Person.age = 20;
console.log(Person);//{name:"lisi",age:20}
Person = {}//wrong,只能修改值，不能修改地址

//这里是传址赋值
var student1 = {"name":"zhangsan"};
var student2 = student1;
student2.name = "lisi";
console.log(student1)//lisi
console.log(student2)//lisi
```
#### 3.21.2 兼容ES6
npm安装babel-core@5；
```html
<!-- C:\Users\Administrator\node_modules\babel-core -->
<script src="browser.min.js"></script>
<script type="text/babel">
	const Name = "zhangsan";
</script>
```
#### 3.21.3 解构赋值
ES6允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。
```js
//数组的结构赋值
var [a,b,c] = [1,2,3];
console.log(a);//1
console.log(c);//3
//可以嵌套，表示数组中的数组
var [a,b,[c1,c2]] = [1,2,[3.1,3,2]];
console.log(c1);//3.1
//不完全解构
var [a,b,c] = [,2,3];
console.log(b)//2
console.log(a);//undefined
//允许设置默认值
var [a,b,c=3] = [1,2];
console.log(c);//3
//覆盖默认值
var [a,b,c=3] = [1,2,4];
console.log(c);//4
```
对象的解构：
```js
var {a,b,c} = {"a":1,"b":2,"c":3};
console.log(c);3
//顺序并不影响，只要变量名在集合里面就可以。
var {a,b,c} = {"a":1,"c":3,"b":2};
console.log(c);3
var {a} = {"b":2};
console.log(a);//undefined

var {b:a} = {"b":2};
console.log(a);//2

//可嵌套
var {a:{b}} = {"a":{"b":1}};
console.log(b);//1
//默认值
var {a,b=2} = {"a":1};
console.log(b);//2
```
字符串的解构赋值：
```js
var [a,b,c,d,e,f] = "我叫卢万林";
console.log(d);//卢
```
解构赋值的用法：
```js
//交换变量的值
var x=1;
var y=2;
[x,y]=[y,x];

//提取函数返回的多个值
function demo(){
    return{"name":"zhangsan","age":21};
}
var {name,age}=demo();
console.log(name);//'zhangsan'

//定义函数参数
function demo({a,b,c}){
    console.log('name'+a);
    console.log('height'+b);
    console.log('weight'+c);
}
demo({a:'zhangsan',b:'1.72m',c:'50kg',d:'8000'});//方便JSON对象中的参数提取

//函数参数的默认值
function demo({name="zhangsan"}){
    console.log("name:"+name);
}
demo({})//zhangsan
```

---
[3.1]:https://github.com/Wanlin-Lu/Front-end-knowledge-summary/blob/master/HCJD/3.Javascript.md#31-js的介绍
[3.2]:https://github.com/Wanlin-Lu/Front-end-knowledge-summary/blob/master/HCJD/3.Javascript.md#32-js的调试
[3.3]:https://github.com/Wanlin-Lu/Front-end-knowledge-summary/blob/master/HCJD/3.Javascript.md#33-js的语法
[3.4]:https://github.com/Wanlin-Lu/Front-end-knowledge-summary/blob/master/HCJD/3.Javascript.md#34-js基本的数据类型
[3.5]:https://github.com/Wanlin-Lu/Front-end-knowledge-summary/blob/master/HCJD/3.Javascript.md#35-操作符和表达式
[3.6]:https://github.com/Wanlin-Lu/Front-end-knowledge-summary/blob/master/HCJD/3.Javascript.md#36-语句
[3.7]:https://github.com/Wanlin-Lu/Front-end-knowledge-summary/blob/master/HCJD/3.Javascript.md#37-数值
[3.8]:https://github.com/Wanlin-Lu/Front-end-knowledge-summary/blob/master/HCJD/3.Javascript.md#38-字符串
[3.9]:https://github.com/Wanlin-Lu/Front-end-knowledge-summary/blob/master/HCJD/3.Javascript.md#39-对象
[3.10]:https://github.com/Wanlin-Lu/Front-end-knowledge-summary/blob/master/HCJD/3.Javascript.md#310-数组
[3.11]:https://github.com/Wanlin-Lu/Front-end-knowledge-summary/blob/master/HCJD/3.Javascript.md#311-函数
[3.12]:https://github.com/Wanlin-Lu/Front-end-knowledge-summary/blob/master/HCJD/3.Javascript.md#312-date日期
[3.13]:https://github.com/Wanlin-Lu/Front-end-knowledge-summary/blob/master/HCJD/3.Javascript.md#313-正则表达式regexp
[3.14]:https://github.com/Wanlin-Lu/Front-end-knowledge-summary/blob/master/HCJD/3.Javascript.md#314-json
[3.15]:https://github.com/Wanlin-Lu/Front-end-knowledge-summary/blob/master/HCJD/3.Javascript.md#315-类型进阶
[3.16]:https://github.com/Wanlin-Lu/Front-end-knowledge-summary/blob/master/HCJD/3.Javascript.md#316-函数进阶
[3.17]:https://github.com/Wanlin-Lu/Front-end-knowledge-summary/blob/master/HCJD/3.Javascript.md#317-原型进阶
[3.18]:https://github.com/Wanlin-Lu/Front-end-knowledge-summary/blob/master/HCJD/3.Javascript.md#318-变量作用域进阶
[3.19]:https://github.com/Wanlin-Lu/Front-end-knowledge-summary/blob/master/HCJD/3.Javascript.md#319-闭包进阶
[3.20]:https://github.com/Wanlin-Lu/Front-end-knowledge-summary/blob/master/HCJD/3.Javascript.md#320-面向对象编程





